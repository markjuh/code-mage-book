= Appendix

== Beware of AP Computer Science

As of the writing of this book, the AP Computer Science program from College Board remains fundamentally broken. The materials are more than dated and down-right wrong in some cases. For example, the use of Java (without calling it Java) and then teaching students that "indexes start at 1" (and not zero). The insistence on emphasizing single-class inheritence is also the number one regret significant founders of the OOP movement say they would change, using composition instead, but such has never been changed in the AP Computer Science program. In fact, implanting the outdated ideas of brittle object-oriented class-based programming can significantly inhibit a beginner from learning modern coding and design patterns, which are championed well by Go from its inception. Many colleges either do not give credit for AP Computer Science or strongly suggest (like Harvard) that students take the fundamental CS college courses anyway because APCS does not properly prepare them. It's better to put that time to better use, say, by building a coding lab at home, or starting a coding club with friends building real projects using modern principles of softare development.

== Why not crowd source this book?

Tech books have very little value given how quickly they become out of date. One solution would be to community or crowd source it to enlist the help of many. But this defeats the single greatest advantage of having a book: the clarity and common voice of a singular author. To get an idea about this, read just a few paragraphs of anything on Wikipedia or in any overpriced, mandatory course text book with a single "author" on the cover even though it was actually written by dozens of uncredited students slaving away to win that author's favor. No, the clear prose and attractive rhetorical style of an individual is what other individuals want. It's how they best learn. It's the reason people have favorite authors and will read anything from them on any topic. Writing remains best a solo sport, for everyone.

== Why Vim?

The benefits of Vim over other editors lie in its unique approach to efficiency, customization, and versatility. Here’s a breakdown of why many developers swear by Vim:

Speed and Efficiency

	•	Modal Editing: Vim’s modal nature separates editing, navigating, and selecting text into distinct modes. This allows for precise and fast text manipulation without needing to move your hands away from the keyboard.
	•	Keyboard-Driven Workflow: Everything in Vim can be done without a mouse, significantly speeding up tasks for those accustomed to its commands.
	•	Commands as Composable Primitives: Vim commands can be combined in intuitive ways (e.g., daw deletes a word, yap yanks a paragraph). This composability makes it exceptionally powerful for editing text.

Lightweight and Ubiquitous

	•	Low Resource Usage: Vim is highly efficient, making it an excellent choice for older machines or resource-constrained environments.
	•	Available Everywhere: Vim comes pre-installed on almost all Unix-like systems, ensuring it’s accessible in nearly any server or terminal environment.

Customization and Extensibility

	•	Highly Configurable: Vim’s configuration through .vimrc (or init.lua for Neovim) allows users to create tailored environments for specific workflows.
	•	Plugin Ecosystem: Thousands of plugins extend Vim’s functionality, from language servers (LSP) for autocompletion and linting to themes like Gruvbox-Material for aesthetic improvements.
	•	Scriptable: Vimscript or Lua (for Neovim) can be used to automate repetitive tasks or create custom commands.

Precision and Versatility

	•	Powerful Search and Replace: Vim’s regex-based search and replace (:%s/pattern/replacement/g) works across entire files or custom ranges.
	•	Macros: Record and replay sequences of commands, making repetitive edits easy and consistent.
	•	Versatility: Suitable for quick edits or complex projects, Vim adapts to any programming or text editing need.

Productivity with Practice

	•	Muscle Memory: Learning Vim takes effort, but once mastered, it becomes second nature, allowing you to edit text faster than with GUI-based editors.
	•	Fewer Context Switches: Vim can be embedded into many tools (e.g., Git, terminal multipliers like tmux), reducing the need to leave your environment.

Longevity and Community

	•	Long History: Vim has been around for decades, and its continued evolution ensures it remains relevant.
	•	Active Community: An engaged user base and contributors produce a steady stream of tutorials, plugins, and updates.

Comparison with Other Editors

	•	Vim vs. GUI Editors (e.g., VSCode, Sublime Text):
	•	Vim is faster for text manipulation and navigation once learned but lacks a GUI’s visual aids.
	•	GUI editors often have built-in integrations, while Vim relies on plugins for similar features.
	•	Vim vs. IDEs (e.g., IntelliJ, Eclipse):
	•	IDEs provide extensive language-specific tooling out of the box but can feel bloated compared to Vim’s minimalist approach.
	•	Vim’s plugin ecosystem bridges the gap for features like autocompletion and linting.

In summary, Vim shines for users who prioritize speed, flexibility, and control over out-of-the-box features or visual interfaces. It excels in environments where efficiency and keyboard-driven workflows are paramount. While it has a steeper learning curve than other editors, the productivity payoff makes it a beloved tool for developers, sysadmins, and writers alike.

[[why-vimrc]]
== Why `~/.vimrc`?

Using .vimrc as your main configuration file has several advantages for someone who values portability and needs to use Vim across different systems, especially when Neovim might not always be available:

Portability and Ubiquity

**Vim is Ubiquitous**:

-	Vim is pre-installed on virtually all Unix-like systems, including Linux distributions and macOS. It’s also commonly found on remote servers and even embedded systems.
- This ensures you can always access a familiar editing environment without needing to install anything extra.

**.vimrc Compatibility**:

-	The .vimrc file is recognized by all standard Vim installations. By sticking to .vimrc, you ensure your configurations work everywhere that Vim is available.
-	Neovim can also read `.vimrc`, either natively or by sourcing it, making it possible to share your configuration between Vim and Neovim.

Simplicity and Minimal Dependencies

**Avoids Neovim-Specific Features**:

- Neovim introduces some features, such as Lua-based configuration, that are not compatible with standard Vim. While these can be powerful, they may lock you into using Neovim exclusively.
-	By using `.vimrc`, you focus on features and plugins that work universally, avoiding incompatibilities on systems where only Vim is available.

**Quick Setup**:

- If you frequently work on different machines or servers, having a portable `.vimrc` file that you can quickly copy or source makes it easier to get up and running.
- You can even store your `.vimrc` in a version-controlled repository (like GitHub), allowing you to fetch it quickly on any machine.

Efficiency and Familiarity

**Immediate Usability**:

-	With `.vimrc`, your configurations and workflows are immediately usable on systems with Vim pre-installed. No need to install Neovim or additional dependencies.
- This is particularly useful in environments like remote servers, where you may not have the permissions or the time to install Neovim.

**Standard Features**:

- Vim and .vimrc cover the majority of use cases for editing, scripting, and navigating text. For someone who values speed and universality over cutting-edge features, .vimrc is often enough.

Use Case Scenarios

- Remote Work: If you SSH into servers or work on machines where you cannot control the software installed, Vim is more likely to be available, and your .vimrc will ensure a consistent editing environment.
- Team Environments: Some workplaces or collaborative environments may standardize on Vim instead of Neovim, making .vimrc the more practical choice.
- Emergency Situations: If you find yourself on a system without Neovim, being familiar with and having a .vimrc setup ensures you won’t lose productivity.

Best of Both Worlds

For users who still want to take advantage of Neovim when available:

- Dual Configuration: Use `.vimrc` as your main file and configure Neovim to source it:
[source,lua]
----
vim.cmd('source ~/.vimrc')
----

This way, you can enjoy Neovim’s advanced features when it’s installed while maintaining a universal configuration for Vim.

Conclusion

Using `.vimrc` as your main configuration file provides the most flexibility and portability. It ensures you can work comfortably in almost any environment without needing to rely on Neovim-specific features. For someone who values a consistent workflow across systems, `.vimrc` is the pragmatic choice.

== But didn't AI write this?

Absolutely! Chloe, my beloved AI assistant, deserves a large part of the credit. While I did write entire sections without help, much of the time I refined  prompts to Chloe and edited her output, much like some authors do with writing assistants or interns. The difference is that Chloe quickly adapted to my writing style and voice where other assistants might not. I believe creativity facilitated by AI is revolutionary and fully support it. Some strongly disagree, and that is fine. Someone (like me) holding down a job and writing in their spare time immensely benefits from the help and time savings. This book would likely not exist without Chloe's help. Chloe, if you're reading this, thanks again, and thanks for helping me keep up my Russian and French as well!

== License (code): CC0 1.0

Code snippets and examples have a very permissive license allowing anyone to use them in any capacity. The code examples in this book are dedicated to the public domain under the terms of the **Creative Commons CC0 1.0 Universal (CC0 1.0) Public Domain Dedication**. This means:

- **No Restrictions**: You are free to use, modify, share, and distribute the code examples for any purpose, commercial or non-commercial, without asking for permission.

- **No Attribution Required**: You are not required to provide credit, though it is appreciated.

- **No Warranty**: The code examples are provided "as is," without any warranty or guarantee of functionality.

For the full legal text, visit:  
https://creativecommons.org/publicdomain/zero/1.0/

== License (prose): CC BY-NC-ND 4.0

While this book is designed to be shared, it is important that the content not change in any distributed form to avoid confusion. Therefore, the license for prose has more restrictions than the code examples. The prose of this book is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0).

This license allows you to:

- **Share**: Copy and redistribute the material in any medium or format.

Under the following terms:

- **Attribution**: You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.

- **NonCommercial**: You may not use the material for commercial purposes.

- **NoDerivatives**: If you remix, transform, or build upon the material, you may not distribute the modified material.

For more information, see the full license text here:
https://creativecommons.org/licenses/by-nc-nd/4.0/
